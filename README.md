## 算法

给出长度 $N$ 、正整数 $M$ 、数字串 $S$ ，从 $S$ 中找到长度不超过 $N$ 且可以被 $M$ 整除的所有子串

假设 $P=S_{[n, m)}\ (m > n, m - n <= N)$ 是一个答案，那么 $P$ 满足 $$P = S_{[0, m)} - S_{[0, n)} * 10^{m-n} \equiv 0 \mod M$$

展开可以得到 $$ S_0*10^{m-1} + ... + S_{m-1}*10^0 \equiv (S_0*10^{n-1} + ... + S_{n-1}*10^0)*10^{m-n} \mod M$$
两边同时除以 $10^{m-1}$ 可以得到 $$ S_0*10^0 + ... + S_{m-1}*10^{-(m-1)} \equiv S_0*10^0 + ... + S_{n-1}*10^{-(n-1)} \mod M$$
设 $ T_x=S_0*10^0 + ... + S_{x-1}*10^{-(x-1)} $, 要找的就是所有 $(m, n)$ 满足 $ T_m\equiv T_n \mod M$，记个 hash 维护一下可以做到 $O(1)$

这里的算法要求 $M$ 和 $10$ 互质，不互质的可以分解一下加点判断

## 实现优化

1. 因为服务器发过来的数不是一个一个来的，每次会来几百个左右，中间间隔在百毫秒量级，可以做很多事情，所以每组结束的时候，可以更新 $S$ 的开头，而不是从最开始那个位置一直算

2. 从 $T_i$ 更新到 $T_{i+1}$ 的时候，$T_{i+1}=(T_i+S_i*10^{-i})\mod M$，这里 $i$ 的范围不超过 $N+每组数的长度$，$S_i$ 只有 $10$ 个，所以可以把每次加的东西预处理出来，避免 mod 计算

3. $M$ 比较大，$M_1$ 可以用 $int64$，$M_2, M_3, M_4$ 都需要做高精度计算，这里优化了高精度计算的进制为 $2$ 的倍数，把除法和取余转成了 位移和 $and$ 操作。另外对 $for$ 循环做了展开，详见 $bign1.h$

4. hash 用数组实现，速度是 trie < hash_map < unordered_map < 数组，hash 计算用二进制

5. 当前位数字等于 $0$ 不需要更新，对 $M_1$ 也不需要查询

## 网络优化
1. 开了多个链接用于发送，轮流用
2. 开了多个链接用于接收，先对齐，之后哪个先收到用哪个

## 其他

最后加了个猜数，当前这一段处理完之后直接枚举后缀，看它乘以 $10^k$ 模 $M$ 的长度是不是小于等于 $k$，直接用高精度算的，比较慢

## 运行

final-v12/

编译：sh compile.sh

运行：sh start_monitor.sh

## Ref

司内c++ socket程序，在 c++_example/